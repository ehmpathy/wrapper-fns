# blueprint v1.i1

## problem analysis

the wish identifies a type safety gap in wrapper-fns:

```ts
const response = await withRetry(
  withTimeout(async () => thread.run(fullPrompt, { outputSchema }), {
    threshold: { seconds: 60 },
  }),
)();
```

this code **should** throw a compile-time type error because:
1. `withRetry` requires a context with `log` methods to log retry attempts
2. the inner function `async () => ...` has no context parameter
3. therefore, `withRetry` cannot access `context.log.warn(...)` at runtime

the current implementation has overloads that bypass this requirement:
```ts
export function withRetry<TInput, TContext extends VisualogicContext, TOutput>(
  logic: () => TOutput, // ⛔ empty inputs override - allows bypassing context requirement
): typeof logic;
```

additionally, the wish requests migrating from `visualogic` to:
- `simple-log-methods` for `ContextLogTrail`
- `as-procedure` for `ProcedureInput`, `ProcedureOutput`, `ProcedureContext`

---

## domain model

### current state

| component | source | purpose |
|-----------|--------|---------|
| `Procedure` | `domain-glossary-procedure` | base procedure type `(input, context) => output` |
| `VisualogicContext` | `visualogic` | context with `{ log: LogMethods }` |
| `ProcedureInput/Output/Context` | `visualogic` | type extractors |

### target state

| component | source | purpose |
|-----------|--------|---------|
| `Procedure` | `domain-glossary-procedure` | base procedure type (unchanged) |
| `ContextLogTrail` | `simple-log-methods` | context with `{ log: LogMethods }` |
| `ProcedureInput/Output/Context` | `as-procedure` | type extractors (re-exports from domain-glossary-procedure) |

### type definitions (from research)

```ts
// from domain-glossary-procedure
export type Procedure<TInput = any, TContext = any, TOutput = any> = (
  input: TInput,
  context: TContext,
) => TOutput;

export type ProcedureInput<T extends Procedure> = Parameters<T>[0];
export type ProcedureContext<T extends Procedure> = Parameters<T>[1];
export type ProcedureOutput<T extends Procedure> = ReturnType<T>;

// from simple-log-methods
export interface ContextLogTrail {
  log: LogMethods;
}
export type HasContextLogTrail<T extends Procedure> =
  ProcedureContext<T> extends ContextLogTrail ? T : never;
```

---

## subcomponent contracts

### withRetry contract (fix required)

```ts
given('withRetry contract')
  then('requires context with log trail')
  then('exposes: withRetry<TProc extends Procedure>(logic: HasContextLogTrail<TProc>) => TProc')
  then('throws compile-time error when procedure lacks ContextLogTrail')
  then('does NOT have empty-inputs overload that bypasses context requirement')
```

**current signature (broken):**
```ts
// allows bypassing context requirement
export function withRetry<TInput, TContext extends VisualogicContext, TOutput>(
  logic: () => TOutput,
): typeof logic;
```

**target signature (fixed):**
```ts
// enforces context requirement at compile time
export function withRetry<TProcedure extends Procedure>(
  logic: TProcedure & HasContextLogTrail<TProcedure>,
): TProcedure;
```

### withTimeout contract (no context requirement)

```ts
given('withTimeout contract')
  then('does not require log trail in context')
  then('exposes: withTimeout<TProc extends Procedure>(logic: TProc, options: { threshold: UniDuration }) => TProc')
```

note: withTimeout does not log anything, so it does not require context.log

### withBottleneck contract (no context requirement)

```ts
given('withBottleneck contract')
  then('does not require log trail in context')
  then('exposes: withBottleneck<T extends (...args) => Promise<any>>(logic: T, options?) => T')
```

note: withBottleneck uses an external library pattern - may need review for consistency

---

## implementation plan

### phase.0: dependency migration

1. add `simple-log-methods` to dependencies
2. add `as-procedure` to dependencies
3. remove `visualogic` from dependencies

### phase.1: update withRetry

1. replace imports from `visualogic` with `as-procedure` + `simple-log-methods`
2. replace `VisualogicContext` with `ContextLogTrail`
3. use `HasContextLogTrail<TProcedure>` constraint to enforce log requirement
4. **remove** the empty-inputs overload `() => TOutput`
5. ensure compile-time error when wrapped function lacks context

**before:**
```ts
import type { Procedure, ProcedureContext, ProcedureInput, ProcedureOutput, VisualogicContext } from 'visualogic';

export function withRetry<TInput, TContext extends VisualogicContext, TOutput>(
  logic: () => TOutput, // ⛔ bypass
): typeof logic;
export function withRetry<TInput, TContext extends VisualogicContext, TOutput>(
  logic: (input: TInput) => TOutput, // ⛔ bypass
): typeof logic;
export function withRetry<TInput, TContext extends VisualogicContext, TOutput>(
  logic: Procedure<TInput, TContext, TOutput>,
): typeof logic;

export function withRetry<TInput, TContext extends VisualogicContext, TOutput>(
  logic: Procedure<TInput, TContext, TOutput>,
): typeof logic {
  return (async (input, context) => {
    try {
      return await logic(input, context);
    } catch (error) {
      context.log.warn('withRetry.progress: caught an error, will retry', { ... });
      return await logic(input, context);
    }
  }) as typeof logic;
}
```

**after:**
```ts
import type { ContextLogTrail, HasContextLogTrail, LogMethods } from 'simple-log-methods';
import type { Procedure, ProcedureContext, ProcedureInput, ProcedureOutput } from 'as-procedure';

/**
 * .what = wraps a procedure to retry once on error
 * .why = provides resilience against transient failures
 */
export const withRetry = <TProcedure extends Procedure>(
  logic: TProcedure & HasContextLogTrail<TProcedure>,
): TProcedure => {
  return ((input: ProcedureInput<TProcedure>, context: ProcedureContext<TProcedure>) => {
    const execute = async (): Promise<ProcedureOutput<TProcedure>> => {
      try {
        return await logic(input, context);
      } catch (error) {
        if (!(error instanceof Error)) throw error;
        context.log.warn('withRetry.progress: caught an error, will retry', {
          error: { message: error.message, stack: error.stack },
        });
        return await logic(input, context);
      }
    };
    return execute();
  }) as TProcedure;
};
```

### phase.2: update withTimeout

1. replace imports from `visualogic` with `as-procedure`
2. no context constraint needed (withTimeout does not log)

**before:**
```ts
import type { Procedure, ProcedureContext, ProcedureInput, ProcedureOutput } from 'visualogic';
```

**after:**
```ts
import type { Procedure, ProcedureContext, ProcedureInput, ProcedureOutput } from 'as-procedure';
```

### phase.3: update test files

1. update imports in test files
2. add test cases for compile-time type errors
3. verify existing tests still pass

### phase.4: update contract/index.ts exports

1. ensure re-exports are correct after migration

---

## test coverage criteria

### unit tests for withRetry

```ts
given('withRetry')
  when('wrapped procedure succeeds on first attempt')
    then('returns result without logging')
  when('wrapped procedure fails once then succeeds')
    then('logs warning and returns result from retry')
  when('wrapped procedure fails twice')
    then('throws the second error')
```

### unit tests for type safety (compile-time)

```ts
given('withRetry type constraints')
  when('procedure has ContextLogTrail in context')
    then('compiles successfully')
  when('procedure lacks log in context')
    then('throws compile-time error via @ts-expect-error')
  when('nullary function without context')
    then('throws compile-time error via @ts-expect-error')
```

### integration tests for wrapper composition

```ts
given('withWrappers composing multiple wrappers')
  when('withRetry + withTimeout composed')
    then('requires procedure to have ContextLogTrail')
    then('throws compile-time error if inner procedure lacks context')
```

### acceptance tests

```ts
given('wrapper-fns public api')
  when('consumer imports withRetry')
    then('type signature enforces ContextLogTrail')
  when('consumer nests withRetry(withTimeout(...))')
    then('compile error if inner function lacks context')
```

---

## file changes summary

| file | action | description |
|------|--------|-------------|
| `package.json` | modify | add `simple-log-methods`, `as-procedure`; remove `visualogic` |
| `src/domain.operations/withRetry.ts` | modify | migrate to new types, fix overloads |
| `src/domain.operations/withTimeout.ts` | modify | migrate imports to `as-procedure` |
| `src/domain.operations/withWrappers.test.ts` | modify | update imports, add type safety tests |
| `src/domain.operations/withRetry.test.ts` | create | unit tests for withRetry behavior |
| `src/domain.operations/withRetry.integration.test.ts` | create | integration tests for wrapper composition |

---

## risks and mitigations

| risk | mitigation |
|------|------------|
| breaking change for consumers | this is intentional - consumers using bypass overloads need to fix their code |
| `as-procedure` or `simple-log-methods` missing types | verified types exist via npm + github research |
| `withBottleneck` uses different pattern | out of scope for this wish; review separately |

---

## success criteria

1. `withRetry(withTimeout(async () => ...))()` **throws compile-time error** due to missing context
2. `visualogic` removed from dependencies
3. `simple-log-methods` and `as-procedure` added to dependencies
4. all existing tests pass
5. new type-safety tests verify compile-time errors
